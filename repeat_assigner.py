from collections import Counter
from datetime import date
from pathlib import Path
from re import findall

from pymatgen.io.cif import CifParser
from pymatgen.io.vasp import Poscar


def assign_repeat(
    cif_path, dst_path=None, poscar_name="POSCAR", repeat_name="repeat.output"
):

    # Check existance of files
    if not isinstance(cif_path, Path):
        assert isinstance(
            cif_path, str
        ), f"Filename neither a String nor a pathlib.Path: {cif_path}"
        cif_path = Path(cif_path)
    assert cif_path.is_file(), f"File does not exist: {cif_path}"
    poscar_path = cif_path.parent.joinpath(poscar_name)
    assert poscar_path.is_file(), f"File does not exist: {poscar_path}"
    repeat_path = cif_path.parent.joinpath(repeat_name)
    assert repeat_path.is_file(), f"File does not exist: {repeat_path}"

    # Parse CIF and POSCAR using pymatgen
    cif_struct = CifParser(cif_path).get_structures(primitive=False)[0]
    poscar_struct = Poscar.from_file(poscar_path).structure

    # A small function to compare floats within a certain tolerance
    def compare_float(a, b, tol=0.01):
        return abs(a - b) < (min(abs(a), abs(b)) * tol)

    # Compare cell vectors between CIF and POSCAR
    assert all(
        [
            compare_float(cif_struct.lattice.a, poscar_struct.lattice.a),
            compare_float(cif_struct.lattice.b, poscar_struct.lattice.b),
            compare_float(cif_struct.lattice.c, poscar_struct.lattice.c),
        ]
    ), f"Cell vectors do not match: CIF vs POSCAR, {cif_path}"

    # Compare cell angles between CIF and POSCAR
    assert all(
        [
            compare_float(cif_struct.lattice.alpha, poscar_struct.lattice.alpha),
            compare_float(cif_struct.lattice.beta, poscar_struct.lattice.beta),
            compare_float(cif_struct.lattice.gamma, poscar_struct.lattice.gamma),
        ]
    ), f"Cell angles do not match: CIF vs POSCAR, {cif_path}"

    # Compare number of atoms between CIF and POSCAR
    assert len(cif_struct) == len(
        poscar_struct
    ), f"Number of atoms do not match: CIF vs POSCAR, {cif_path}"

    # Get atomic symbols and fractional coordinates for all atoms
    symbols = [atom.specie.symbol for atom in poscar_struct]
    frac_xyz = [atom.frac_coords for atom in poscar_struct]

    # Compare the numbers of each element between CIF and POSCAR
    assert Counter([str(atom.specie) for atom in cif_struct]) == Counter(
        symbols
    ), f"Atom counts do not match: CIF vs POSCAR, {cif_path}"

    # Parse REPEAT file and compare number of atoms between POSCAR and REPEAT
    repeat_lines = findall(
        r"Charge [0-9]+ of type [0-9]+ = [0-9.-]+", repeat_path.read_text()
    )
    assert len(repeat_lines) == len(
        poscar_struct
    ), f"Number of atoms do not match: POSCAR vs REPEAT, {cif_path}"

    # While check the order of atoms, extract REPEAT charges
    repeat_charges = []
    for repeat_line, poscar_atom in zip(repeat_lines, poscar_struct):
        line_split = repeat_line.split()
        assert (
            int(line_split[4]) == poscar_atom.specie.Z
        ), f"Order of atoms does not match: POSCAR vs REPEAT, {cif_path}"
        repeat_charges.append(line_split[-1])

    # Reassign labels for all atoms
    labels = []
    label_counter = {element: 0 for element in set(symbols)}
    for symbol in symbols:
        label_counter[symbol] += 1
        labels.append(f"{symbol}{label_counter[symbol]}")

    # Create preambles for the new CIF file
    new_cif = "# Generated by REPEAT Assigner based on pymatgen\n"
    new_cif += f"data_{cif_path.name.replace('.cif', '')}\n"
    new_cif += "_audit_creation_date              "
    new_cif += date.today().strftime("%Y-%m-%d") + "\n"
    new_cif += "_audit_creation_method            REPEAT_Assigner\n"

    # Create cell info for the new CIF file
    new_cif += f"_cell_length_a                    {cif_struct.lattice.a:.6f}\n"
    new_cif += f"_cell_length_b                    {cif_struct.lattice.b:.6f}\n"
    new_cif += f"_cell_length_c                    {cif_struct.lattice.c:.6f}\n"
    new_cif += f"_cell_angle_alpha                 {cif_struct.lattice.alpha:.6f}\n"
    new_cif += f"_cell_angle_beta                  {cif_struct.lattice.beta:.6f}\n"
    new_cif += f"_cell_angle_gamma                 {cif_struct.lattice.gamma:.6f}\n"
    new_cif += f"_cell_volume                      {cif_struct.lattice.volume:.6f}\n"

    # [ASSUMED P1] Create symmetry info for the new CIF file
    new_cif += "_symmetry_space_group_name_H-M    P1\n"
    new_cif += "_symmetry_Int_Tables_number       1\n"
    new_cif += "loop_\n"
    new_cif += "    _symmetry_equiv_pos_site_id\n"
    new_cif += "    _symmetry_equiv_pos_as_xyz\n"
    new_cif += "    1  x,y,z\n"

    # Create atom info for the new CIF file
    new_cif += "loop_\n"
    new_cif += "    _atom_site_type_symbol\n"
    new_cif += "    _atom_site_label\n"
    new_cif += "    _atom_site_fract_x\n"
    new_cif += "    _atom_site_fract_y\n"
    new_cif += "    _atom_site_fract_z\n"
    new_cif += "    _atom_type_partial_charge\n"

    # Adjust widths for the symbols and labels column
    symbol_width = len(max(symbols, key=len))
    label_width = len(max(labels, key=len))

    # Loop over all atoms and create info line for each of them
    for symbol, label, frac, charge in zip(symbols, labels, frac_xyz, repeat_charges):
        new_cif += f"    {symbol:{symbol_width}}  {label:{label_width}}  "
        new_cif += "{:.6f}  {:.6f}  {:.6f}  ".format(*frac) + f"{charge}\n"

    # Write the new CIF
    if dst_path is None:
        dst_path = cif_path.parent
    dst_path.joinpath(cif_path.name.replace(".cif", "_repeat.cif")).write_text(new_cif)
